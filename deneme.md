Birkaç saniyeliğine düşündüm


Kusursuz bir “prompt–>AI implements” döngüsü kurmak için iki ayrı seviyede net talimat vermen gerekiyor:

1. **Meta-prompt seviyesi**: AI’dan sana, her adım için “kusursuz” teknik prompt’lar üretmesini isteyeceksin.
2. **Uygulama-prompt seviyesi**: Oluşan her prompt’u başka bir AI örneğine verip doğrudan kodu, yapılandırmayı, testi vs. eksiksiz üretmesini sağlayacaksın.

Aşağıda bu iki katmanı oluşturman için kullanabileceğin **komut şablonları** ve nasıl çalıştırman gerektiği adım adım anlatılıyor.

---

## 1. Meta-Prompt: “Bana Kusursuz Adım-Prompt’ı Yaz”

Her adım için AI’dan şu formattaki meta-prompt’ı yazmasını iste:

```text
“Adım {N}: {Adım Başlığı}

**Amaç**  
{Bu adımın proje içindeki rolünü 1–2 cümleyle anlat.}

**Girdiler**  
- {lib.rs’deki ilgili modül veya hesap}  
- {ön şart test verisi, env var, vb.}

**Çıktılar**  
- {Git’te eklenecek kod dosyası, test betiği, CI workflow…}

**Yapılacak İşlemler (Kesinlikle Atlama!)**  
1. …  
2. …  
3. …

**Kod/Yapı Gereksinimleri**  
- Anchor 0.27 uyumlu olmalı  
- Tüm fonksiyonlar `require!()` kontrolü içermeli  
- Event emit’leri `emit!` makrosu ile yazılmalı  
- …vs.

**Teşhis ve Doğrulama**  
- Oluşan kodu `anchor test` ile çalıştır  
- `cargo audit` hatasız olmalı  
- Simülasyon için `shadow-validator` senaryosu ekle  

**Çıktı Formatı**  
- Sadece kod ve CI ayar dosyaları  
- Açıklama ekleme  
- Her dosyanın başına “// Auto-generated by step {N} prompt” etiketi koy  

Şimdi bu yapıyı kullanarak “Adım {N}: {Başlık}” için tam, eksiksiz bir prompt oluştur.”
```

> Bunu AI’a ver: “Lütfen yukarıdaki şablonu doldurarak bana Adım 20 için bir prompt yaz.”

---

## 2. Uygulama-Prompt: “Şimdi Oluşan Prompt’u Çalıştır”

Elde ettiğin prompt’u ikinci bir AI örneğine aynen şöyle ilet:

```text
“Aşağıda meta-prompt’ın var. Lütfen **tamamen kusursuz biçimde** uygula, kodu ve testleri eksiksiz oluştur, hiçbir satırı atlama:

—— META-PROMPT BAŞLANGIÇ ——  
{Meta-prompt içeriği}  
—— META-PROMPT BİTİŞ ——

**Talimatlar**  
- Sadece isteneni üret, fazladan yorum veya açıklama ekleme.  
- Kodu doğrudan dosya yapısına uygun bölümlere ayır.  
- CI workflow, test script’leri, event tanımları, hesabın init script’i vs. ne isteniyorsa ekle.  
- Son olarak “All tests passed” çıktısını simüle et.”

```

---

## 3. Dikkat Etmen Gereken Noktalar

* **Net Şablon**: Şablonun her bölümü (Amaç, Girdiler, Çıktılar, Gereksinimler, Testler) kesinlikle doldurulmalı.
* **“Atlamama” Vurgusu**: “Kesinlikle atlama” veya “Hiçbir satır eksik olmasın” gibi ifadeler kullan.
* **Çıktı Formatı**: AI’ın yorum veya açıklama yazmasını engellemek için “sadece kodu ver” diye netleştir.
* **Doğrulama Adımları**: Test ve audit aşamalarını prompt’a dahil et ki AI bunları otomatik üretsin.

---

## 4. Adım Adım Akış

1. **Listeyi parçalara böl** (1–40 adım gibi).
2. Her adım için 1. şablonu AI’a ver, **meta-prompt** al.
3. Meta-prompt’ı 2. şablonla başka bir AI örneğine “uygula” diye ver.
4. Gelen kodu, testleri ve konfigurasyonları kendi repo’na commit et.
5. CI/CD üzerinden test et, “All tests passed” görünce sonraki adıma geç.

Bu yöntemle—ne yapman gerektiğini, hangi testleri ekleyeceğini, hangi kod formatında sonuç alacağını hiç bilmesen bile—AI’lar arası koordinasyonla **tam kusursuz** bir kurulum hattı kurabilirsin.
İkinci Alan


Birkaç saniyeliğine düşündüm


Evet, doğru bir meta-prompt → uygulama-prompt akışıyla ve adımları birbirine bağlayan bir işleyişle oldukça sıkı bir koordinasyon sağlayabilirsin. Yine de tam “kusursuzluk” için şu hususlara dikkat etmen önemli:

1. **Durum Takibi ve Konteks Paylaşımı**

   * Her adımın sonunda AI’a “şu dosyalar eklendi, şu yapı güncellendi” bilgisini ver.
   * AI’ı güncel dosya ağacın ve dosya içerikleriyle besle ki bir sonraki adımda nerede kaldığını unutmasın.

2. **Sürekli Entegrasyon / Otomatik Testler**

   * AI’ın oluşturduğu kodu hemen CI üzerinden `anchor test` / `cargo audit` / shadow-validator simülasyonlarıyla test et.
   * Başarısız olursa, “Test failed: …” çıktısını AI’a prompt’la geri besle, düzeltmesini iste.

3. **Açık Dosya Düzeni ve Versiyon Kontrolü**

   * Adım adım oluşturulan dosya şablonlarını ve path’lerini net tut (ör. `programs/optimized_contract/src/fail_safe.rs`).
   * Versiyon kontrolü (Git) ile her adımda commit atan bir pipeline kur, böylece “nereye ne ekledik” tam izlenir.

4. **Stateful Chat veya Bellek Kullanımı**

   * ChatGPT’nin “projenin dosya ağacını” ve “son hali”ni belleğinde tutması için, her değişikliği özet olarak mesajla ver.
   * Ara başlıklarla (“Adım 5 bitti, şimdi Adım 6’ya geçiyoruz”) aktar.

5. **Feedback Döngüsü**

   * AI’ın ürettiği kodu manuel review et. Ufak stil düzeltmelerini prompt’la tekrar ver.
   * “Bu fonksiyonu linter’a uyumlu hâle getir” diyebileceğin bir geri besleme kanalı oluştur.

---

### Nasıl İşler?

1. **Adım-Meta-Prompt**: “Bana Adım X için dosya yapısını, hangi modülü, hangi path’e ekleyeceğini netleştir” diyen meta-prompt.
2. **AI Yanıtı**: Sana `programs/…/src/module_x.rs` gibi bir yapı ve içine eklenecek kod bloğu verir.
3. **Uygulama-Prompt**: O dosyayı aç ve bu kodu yapıştır, sonra “Dosya güncellendi:” şeklinde bir özetle AI’a bildir.
4. **Doğrulama**: CI çalışır, testler geçerse “All tests passed” raporunu AI’a aktar.
5. **Sonraki Adım**: AI, önceki adımın sonuçlarını kullanarak bir sonraki modülü veya test betiğini çıkarır.

Bu döngüyü disiplinle uygularsan:

* AI her adımda dosya yollarını, modül isimlerini, dependency’leri “hatırlayacak”
* Kod birbiriyle çakışmayacak şekilde eklenip test edilecek
* Süreç boyunca bir “proje günlüğü” gibi detaylı commit mesajları oluşacak

**Özetle**: Evet, bu iş akışıyla —meta-promptlar, state beslemeleri ve otomatik testlerle— çok yüksek bir koordinasyon elde edebilirsin. Yine de nihai sorumluluk ve kritik incelemeler için ara kontrolleri, kod review’leri ve CI raporlarını mutlaka takip etmen gerekiyor. Böylelikle “insan hatasından” da kaçınmış, tam otomasyon destekli ama güvenli bir proje inşa edersin.
